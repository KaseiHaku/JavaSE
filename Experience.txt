1. 有序的账号生成问题
    解决方案：采用数据库存值，每次生成取值即可
    改进方案：部署 Redis 缓存数据库，把值保存在 Redis 中


2. 订单发货问题
    解决方案：数据库中建一张发货表，用于保存发货数据，代码中开启线程读取发货表数据进行处理，处理完成后删除该条几录
                难点：开启新线程死循环查询，将大量占用 cpu 资源
    改进方案：采用 ActiveMQ 消息队列，将发货数据保存在消息队列中，用线程处理消息队列中的发货数据
    
3. 面对多种登陆方式的代码设计
    解决方案1：面向接口设计，所有方式独立为一个类，该类中有个固定的方法
    解决方案2：处理中心设计，所有方式独立为一个类，并创建一个处理中心类，重载方法处理每一种方式
    
4. 用户登陆注册设计
    方案：用户信息表 和 登陆验证表 分离，通过用户账号关联

5. 交易中心设计
    方案：订单表（包含付款方式）、付款表（包含付款人）、发货表（包含发货方式）、订单货物表（包含发货方式）

6. 纯接口 Web API 设计
    方案：采用 JWT token 方式，前后端交互完全通过 AJAX ，代码请求参数为 Form 或者 JSON，返回数据永远为 JSON ，
    
7. 设计原则
    模块化：系统中所有独立的功能，都应该独立为一个模块供其他模块使用
    
8. 进程间通信问题
    方案：共享内存、等待/通知、消息传递、

9. 进程间同步
    方案1：synchronize wait() notify() notifyAll()
    方案2：Lock 锁对象 条件对象 await() signal() signalAll()

10. Junit 不支持多线程：主线程执行完成就退出，
    解决方案：让主线程 sleep(10000) 一段时间，缺陷：不知道子线程什么时候执行完成，尽可能多的设置睡眠时间
    
11. 线程被 notify() 通知唤醒之后，是从原来的  wait() 方法处开始往下执行的



 
