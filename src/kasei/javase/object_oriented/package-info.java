package kasei.javase.se.objectoriented;

/** Java 知识主要名词解释
 * JPA:Java Presistence API -- java 持久化 API -- 其中的事务实现靠数据库自身
 * JTA:Java Transaction API -- java 事务API -- 其中的事务实现靠应用服务，可实现分布式数据库事务
 * IOC:
 * AOP:
 * ORM:Object Relation Mapping -- 对象关系映射 --用于数据库表和Java程序类之间的对应
 * **/


/* Java ***************************************************************************
 *Object
 *  │
 *  ├─ abstract ─ 实现类1 ─ 实现类2
 *  ├─ interface ─ 实现类1 ─ 实现类2
 *  └─ FatherClass
 *         └─ ChildClass
 *
 *  对象和类的关系：对象是具体的类，层级关系：
 *  抽象类和实现类的关系：抽象类是所有实现类的统一调用接口；层级关系：同层
 *  接口和实现类的关系：接口是所有实现类的统一调用接口；层级关系：同层
 *  父类和子类的关系：子类对象可以造型为父类对象；层级关系：子类为父类对象的下一层
 *
 *  在 Java 中，你只能通过引用操作对象，除了基本类型以外；比如 Integer i = new Integer();i是引用， new出来的东西才是对象
 * */
/*
Java 静态属性 和 静态方法 在类继承时的表现：
结论：java中静态属性和静态方法可以被继承，但是没有被重写(overwrite)而是被隐藏.
原因：
1). 静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制及可以调用。
    如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为"隐藏"。
    如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在"隐藏"的这种情况。
2). 多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。
    有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是："重写"后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。

坑: 当子类 继承 父类 静态方法 时，静态方法访问了静态字段，那么调用 SubCls.staticMethod() 还是会使用 父类 的 staticField，不管子类有没有定义同名的 staticField
*/
