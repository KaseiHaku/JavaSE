并发：指宏观上同时发生，例如单核 CPU 按时间分片来执行不同的任务
并行：指两件事情同一时刻发生，例如 CPU 的两个核心同时执行

进程：代码在内存中的表现形式
线程：一个进程包含多个线程

线程的状态有哪些？
    Thread$State 内部类中的状态： 新建、可执行、阻塞、等待、定时等待、终止

Java 默认有几个线程？
    main, GC

Java 能开启线程吗？
    不能，最终是调用 Thread#start0() native 方法，该方法是 C++ 实现的，Java 无法直接操作硬件

什么情况下会发生线程并发问题？
    多个线程同时操作共享内存时，才会出现并发同步问题

volatile 关键字的作用是什么？
    1. 保证可见性
        JMM(Java Memory Model) 同步的约定是什么？
                1. 线程解锁前，必须把 线程工作内存 中的共享变量立刻刷回 主存。
                2. 线程加锁前，必须读取 主存 中的最新值到 线程工作内存
                3. 保证加锁和解锁是同一把锁
        Java 线程读取主存数据的 8 个操作：
            1. 从主存中 read 数据，并 load 到工作内存
            2. 执行引擎 use 工作内存中的数据，并 assign 回工作内存，每个线程独立一个执行引擎，即独立一个 PC 寄存器
            3. 工作内存 write 数据，并 store 到主存
            4. lock 和 unlock
    2. 不保证原子性
            怎么在不使用 Lock 和 synchronized 的情况下，保证原子性？
                使用原子类，解决原子性问题。
            为什么原子类能保证原子性？
                Unsafe 类，里面使用的都是 native 方法，可能是 CPU 汇编指令来保证的

    3. 禁止指令重排
        源代码 -> 编译器优化重排 -> 指令并行也可能会重排 -> 内存系统也可能重排 -> 执行



wait 和 sleep 的区别？
    1. 来自不同的类，wait => Object;  sleep => Thread
    2. sleep 不释放锁，wait 释放锁
    3. 使用范围的不同：sleep 可以在任何地方使用，wait 必须在同步代码块中使用
    4. 异常捕获问题：wait 不需要捕获异常，sleep 必须捕获异常

基本概念：
    1. java 所有变量都保存在主存（即内存）中
    2. 每一个线程都有一个独立的内存，叫作线程的工作内存
    3. 线程之间不能相互访问对方的工作内存
线程对变量的操作步骤:    
    1. 先从主存复制一份到当前线程的工作内存中
    2. 修改当前线程中的变量值
    3. 不定时的写入主存
    读取内存 -> 线程缓存 -> CPU 计算 -> 线程缓存赋值 -> 同步到内存
volatile 关键字具有以下含义：
    1. 线程对自己工作内存中变量的写入操作立即更新到主存，并给其他线程的工作内存中的相同变量打失效 flag
    2. 每次从工作内存读取变量前先检查失效 flag 是否失效，如果失效，则从主存读取
    坑:
    由于只在读取前检查 flag，如果线程在读取后被阻塞，且变量值被其他线程修改，就会破坏原子性

什么是 线程安全 / 同步?
    概念：
        多线程同时操作共享变量时，才会出现 线程安全/同步 问题
        原子性: 即一个操作或者多个操作 要么全部执行且执行的过程不会被任何因素打断，要么就都不执行。
        可见性：一个 线程修改，其他线程立马可见
        有序性: 必须保证先后顺序
    如何产生?
        - CPU 级别:
          CPU 处理数据时，会把 Memory 中的数据复制一份到 Cache 中，然后 CPU 执行指令，并将结果写回到 Cache 中，最后 Cache 会将数据 Flush 回到 Memory 中。
          这在 多线程 或 多CPU 时，会造成 Cache 中的数据不一致，因为每个 线程/CPU 都有自己的 Cache
        - Java 级别:
          Java 执行过程中，同样会在 线程栈 中复制要操作的值，修改完，最后再 Flush 回 Memory
        总之就是:
            多线程同时修改一个 共享变量，导致 共享变量 最终值不确定。
            @tips 只要在 CPU 层面，超过一个 机器/CPU 周期 的指令，都会产生 同步问题
    如何解决？
        只要能保证并发访问时，线程 A 对 变量 Var 的修改，任何其他线程可以立刻获取到即可。
        例如：
            同一时刻只能有一个线程操作共享变量
            内存屏障
    java 保证线程安全的方法有哪些？
        - 不共享变量
        - 共享变量 只读
        - 原子类 AtomicXxx: 通过 底层硬件支持 / 内存屏障 / 锁 等机制实现
        - 锁: synchronized / Lock


创建线程的方法
    1，继承Thread类，重写run方法；
    2，实现Runnable接口，重写run方法，但是比继承Thread类好用，实现接口还可以继承类，避免了单继承带来的局限性；
    3，实现callable接口，重写call方法，有返回值、可以抛异常、结果有缓存
    4，使用实现了Executor接口的ThreadPoolExecutor来创建线程池。
 






